# Copyright (C) 2001-2018, Python Software Foundation
# For licence information, see README file.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-21 09:48+0100\n"
"PO-Revision-Date: 2019-05-10 19:36+0200\n"
"Language-Team: FRENCH <traductions@lists.afpy.org>\n"
"Language: fr\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Last-Translator: Louis Portay <lportay@student.42.fr>\n"
"X-Generator: Poedit 2.2.1\n"

#: ../Doc/howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "Programmation Fonctionelle INTRODUCTION"

#: ../Doc/howto/functional.rst:0
msgid "Author"
msgstr "Auteur"

#: ../Doc/howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../Doc/howto/functional.rst:0
msgid "Release"
msgstr "Version"

#: ../Doc/howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../Doc/howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to the "
"concepts of functional programming, we'll look at language features such as :"
"term:`iterator`\\s and :term:`generator`\\s and relevant library modules "
"such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"Dans ce document, nous étudierons les fonctionnalités de Python adaptées "
"pour programmer dans un style fonctionnel. Après une introduction aux "
"concepts de la programmation fonctionnelle, nous verrons certaines "
"fonctionnalités du langage comme  les :term:`itérateurs`, les :term:"
"`générateurs` et les librairies pertinentes tel que :mod:`itertools` et :mod:"
"`functools`."

#: ../Doc/howto/functional.rst:16
msgid "Introduction"
msgstr "Introduction"

#: ../Doc/howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if you're "
"just interested in learning about Python language features, skip to the next "
"section on :ref:`functional-howto-iterators`."
msgstr ""
"Cette section explique le concept de base de la programmation fonctionnelle; "
"Si vous êtes intéressé par apprendre des fonctionnalités de Python, passez à "
"la section suivante sur les :ref:`functional-howto-iterators`."

#: ../Doc/howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different ways:"
msgstr ""
"Les langages de programmation peuvent décomposer les problèmes de plusieurs "
"façons différentes:"

#: ../Doc/howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input.  C, "
"Pascal, and even Unix shells are procedural languages."
msgstr ""
"La plupart des langages de programmation sont dits **procéduraux**: Les "
"programmes sont des listes d'instructions qui disent à l'ordinateur quoi "
"faire avec l'entrée reçue. C, Pascal et même les shells Unix sont des "
"langages procéduraux."

#: ../Doc/howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes the "
"problem to be solved, and the language implementation figures out how to "
"perform the computation efficiently.  SQL is the declarative language you're "
"most likely to be familiar with; a SQL query describes the data set you want "
"to retrieve, and the SQL engine decides whether to scan tables or use "
"indexes, which subclauses should be performed first, etc."
msgstr ""
"Dans les langages dits **déclaratifs**, on écrit une spécification qui "
"décrit le problème à résoudre et l'implémentation du langage choisit comment "
"effectuer le calcul le plus efficace pour arriver à la solution. SQL est le "
"langage déclaratif avec lequel vous êtes probablement le plus familier; une "
"requête SQL décrit l'ensemble de données que vous voulez récupérer et le "
"moteur SQL décide soit de scanner les tables soit d'utiliser les indices, "
"détermine quel sous-paragraphe doit être exécuté en premier, etc..."

#: ../Doc/howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this internal "
"state in some way. Smalltalk and Java are object-oriented languages.  C++ "
"and Python are languages that support object-oriented programming, but don't "
"force the use of object-oriented features."
msgstr ""
"Les programmes écrits avec des langages dits **orientés objets** manipulent "
"des collections d'objets. Ces objets conservent un état interne et ont des "
"méthodes qui accèdent ou modifient cet état interne d'une façon ou d'une "
"autre. Smalltalk et Java sont des langages orientés objets. C++ et Python "
"sont des langages qui implémentent le paradigme objet mais ne force pas son "
"utilisation."

#: ../Doc/howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have any "
"internal state that affects the output produced for a given input.  Well-"
"known functional languages include the ML family (Standard ML, OCaml, and "
"other variants) and Haskell."
msgstr ""
"La programmation **fonctionnelle** décompose un probléme en un ensemble de "
"fonctions. Idéalement, des fonctions qui ne prennent que des entrées et des "
"sorties et qui ne conservent aucun état interne qui affecte la sortie "
"produite pour une entrée donnée. Parmi les langages fonctionnels connus on "
"peut citer la famille ML (Standard ML, OCaml ainsi que d'autres variantes) "
"et Haskell."

#: ../Doc/howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one particular "
"approach to programming.  This often makes it difficult to write programs "
"that use a different approach.  Other languages are multi-paradigm languages "
"that support several different approaches. Lisp, C++, and Python are multi-"
"paradigm; you can write programs or libraries that are largely procedural, "
"object-oriented, or functional in all of these languages.  In a large "
"program, different sections might be written using different approaches; the "
"GUI might be object-oriented while the processing logic is procedural or "
"functional, for example."
msgstr ""
"Les concepteurs de certains langages choisissent de mettre l'accent sur une "
"approche particulière de la programmation. Cela rend souvent l'écriture de "
"programmes avec une approche différente difficile. D'autres langages sont "
"multi-paradigmes, cela veut dire qu'ils proposent différentes approches. "
"Lisp, C++ et Python sont multi-paradigmes; vous pouvez écrire des programmes "
"ou des librairies dans un style majoritairement procédural, orienté objet ou "
"bien fonctionnel dans tous ces langages.  Dans un programme d'envergure, "
"différentes portions peuvent être écrites en utilisant différentes "
"approches; l'interface graphique peut être orienté objet tandis que la "
"logique du programme peut être procédural ou fonctionnel par exemple."

#: ../Doc/howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional style "
"discourages functions with side effects that modify internal state or make "
"other changes that aren't visible in the function's return value.  Functions "
"that have no side effects at all are called **purely functional**.  Avoiding "
"side effects means not using data structures that get updated as a program "
"runs; every function's output must only depend on its input."
msgstr ""
"Dans un programme fonctionnel, l'entrée parcourt un ensemble de fonctions. "
"Chaque fonction agit sur cette entrée et génère une sortie. Le style "
"fonctionnel dissuade l'emploi de fonctions avec des effets de bord qui "
"modifient un état interne ou effectue d'autres changements qui ne sont pas "
"visibles dans la valeur de retour de la fonction.  Les fonctions qui n'ont "
"aucun effet de bord sont dites **pures** . Eviter les effets de bord "
"implique de ne pas utiliser de structure de données qui sera modifiée "
"lorsque le programme est exécuté; chaque retour de fonction doit dépendre "
"uniquement de ses paramètres."

#: ../Doc/howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have assignment "
"statements such as ``a=3`` or ``c = a + b``, but it's difficult to avoid all "
"side effects.  Printing to the screen or writing to a disk file are side "
"effects, for example.  For example, in Python a call to the :func:`print` "
"or :func:`time.sleep` function both return no useful value; they're only "
"called for their side effects of sending some text to the screen or pausing "
"execution for a second."
msgstr ""
"Certains langages sont très stricts sur la pureté des fonctions et n'ont pas "
"d'assignations comme ``a=3`` ou ``c = a + b``, mais il est difficile de se "
"débarasser de tous les effets de bord. Imprimer quelque chose sur l'écran ou "
"écrire sur le disque sont des effets de bord par exemple. Par exemple, en "
"Python, un appel à la fonction  :func:`print` ou à :func:`time.sleep` ne "
"renvoie aucune valeur utile; elles sont seulement appelées pour leurs effet "
"de bord d'envoyer du texte à l'écran ou de mettre en pause l'exécution pour "
"une seconde."

#: ../Doc/howto/functional.rst:74
msgid ""
"Python programs written in functional style usually won't go to the extreme "
"of avoiding all I/O or all assignments; instead, they'll provide a "
"functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have "
"other side effects."
msgstr ""
"Les programmes écrits dans un style fonctionnel avec Python ne suivent pas "
"la voie extrême d'éviter toute I/O ou de n'effectuer aucune assignation; Ils "
"affichent plutôt une interface en apparence fonctionnelle avec des "
"mécanismes non-fonctionnelles en interne. Par exemple, l'implémentation "
"d'une fonction utilisera toujours des assignations à des variables locales, "
"mais ne modifiera pas de variables globales et n'aura pas d'autres effets de "
"bord."

#: ../Doc/howto/functional.rst:80
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, and "
"programs consist of making the right set of state changes.  Functional "
"programming wants to avoid state changes as much as possible and works with "
"data flowing between functions.  In Python you might combine the two "
"approaches by writing functions that take and return instances representing "
"objects in your application (e-mail messages, transactions, etc.)."
msgstr ""
"La programmation fonctionnelle peut être considéré comme l'opposé de la "
"programmation orienté objet. Les objets sont des petites capsules contenant "
"un état interne accompagné d'un ensemble de méthodes qui permettent de "
"modifier cet état, et les programmes consistent à effectuer la bonne "
"combinaison de changements d'états. La programmation fonctionelle souhaite "
"éviter autant que possible les changements d'état et fonctionne avec les "
"données passant d'une fonction à l'autre.  Python vous laisse combiner les "
"deux approches en écrivant des fonctions qui prennent en paramètre et "
"renvoient des instances modélisant des objets dans votre application (e-"
"mails, transactions, etc.)."

#: ../Doc/howto/functional.rst:89
msgid ""
"Functional design may seem like an odd constraint to work under.  Why should "
"you avoid objects and side effects?  There are theoretical and practical "
"advantages to the functional style:"
msgstr ""
"Le paradigme fonctionnel peut sembler être une contrainte étrange sous "
"laquelle travailler. Pourquoi devoir éviter les objets et les effets de "
"bord ? Il y a des avantages théoriques et pratiques au style fonctionnel:"

#: ../Doc/howto/functional.rst:93
msgid "Formal provability."
msgstr "Prouvabilité formelle."

#: ../Doc/howto/functional.rst:94
msgid "Modularity."
msgstr "Modularité."

#: ../Doc/howto/functional.rst:95
msgid "Composability."
msgstr "Composabilité."

#: ../Doc/howto/functional.rst:96
msgid "Ease of debugging and testing."
msgstr "Simplicité à débugger et à tester."

#: ../Doc/howto/functional.rst:100
msgid "Formal provability"
msgstr "Prouvabilité formelle"

#: ../Doc/howto/functional.rst:102
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical proof "
"that a functional program is correct."
msgstr ""
"Un bénéfice théorique de la programmation fonctionnelle est la simplicité de "
"prouver mathématiquement qu'un programme est correct."

#: ../Doc/howto/functional.rst:105
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces "
"the right result for all possible inputs."
msgstr ""
"Les chercheurs ont longtemps été intéressés par des moyens de prouver "
"mathématiquement que des programmes sont corrects. Cela est différent de "
"tester un programme sur de nombreuses entrées et de conclure que son "
"résultat est souvent le bon, ou de lire le code source et de conclure que le "
"code semble bon; le but ici est plutôt de produire une preuve rigoureuse "
"qu'un programme produit le bon résultat pour toutes les entrées possibles."

#: ../Doc/howto/functional.rst:112
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's variables "
"that are always true.  For each line of code, you then show that if "
"invariants X and Y are true **before** the line is executed, the slightly "
"different invariants X' and Y' are true **after** the line is executed.  "
"This continues until you reach the end of the program, at which point the "
"invariants should match the desired conditions on the program's output."
msgstr ""
"La technique utilisée pour prouver l'exactitude des programmes consiste à "
"établir des **invariants**, ce sont certaines propriétés des paramètres et "
"des variables du programme qui sont toujours vraies. Pour chaque ligne de "
"code, on montre que si les invariants X et Y sont vrais **avant** d'exécuter "
"la ligne,  les invariants légèrements différents X' et Y' sont vrais après "
"que la ligne soit exécutée. Cela continue jusqu'à la fin du programme, où "
"les invariants doivent correspondre à la sortie attendue du programme."

#: ../Doc/howto/functional.rst:120
msgid ""
"Functional programming's avoidance of assignments arose because assignments "
"are difficult to handle with this technique; assignments can break "
"invariants that were true before the assignment without producing any new "
"invariants that can be propagated onward."
msgstr ""
"Le rejet des assignations en programmation fonctionnelle vient du fait que "
"les assignations sont difficiles à gérer avec cette technique; Les "
"assignations peuvent induire en erreur des invariants qui étaient vrais "
"avant l'assignation sans produire de nouveaux invariants qui peuvent être "
"propagés dans la suite du programme."

#: ../Doc/howto/functional.rst:125
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that are "
"several pages long; the proof of correctness for a moderately complicated "
"program would be enormous, and few or none of the programs you use daily "
"(the Python interpreter, your XML parser, your web browser) could be proven "
"correct.  Even if you wrote down or generated a proof, there would then be "
"the question of verifying the proof; maybe there's an error in it, and you "
"wrongly believe you've proved the program correct."
msgstr ""
"Malheureusement, prouver l'exactitude des programmes est globalement "
"impraticable et peu pertinent pour les programmes écrits en Python. Même des "
"programmes triviaux nécéssitent des preuves longues de plusieurs pages; "
"Prouver l'exactitude d'un programme modérément compliqué serait démesuré, et "
"peu voire aucun des programmes que vous utilisez quotidiennement "
"(L'interpréteur Pyhton, votre parser XML, votre navigateur web...) pourrait "
"être prouvé comme étant exacts. Même si vous écriviez ou génériez une telle "
"preuve, il y aurait ensuite la question de vérifier la preuve elle-même; "
"peut-être contient-elle une erreur alors que vous pensiez avoir prouvé "
"l'exactitude du programme."

#: ../Doc/howto/functional.rst:136
msgid "Modularity"
msgstr "Modularité"

#: ../Doc/howto/functional.rst:138
msgid ""
"A more practical benefit of functional programming is that it forces you to "
"break apart your problem into small pieces.  Programs are more modular as a "
"result.  It's easier to specify and write a small function that does one "
"thing than a large function that performs a complicated transformation.  "
"Small functions are also easier to read and to check for errors."
msgstr ""
"La programmation fonctionnelle a comme bénéfice plus pratique de vous "
"obliger à découper votre problème en plus petits morceaux. Les programmes "
"sont par conséquent plus modulaires. Il est plus facile de conceptualiser et "
"d'écrire une petite fonction qui fait une seule chose plutôt qu'une longue "
"fonction qui effectue une transformation compliquée. Les fonctions courtes "
"sont aussi plus faciles à lire et à corriger."

#: ../Doc/howto/functional.rst:146
msgid "Ease of debugging and testing"
msgstr "Facilité pour debugger et tester"

#: ../Doc/howto/functional.rst:148
msgid "Testing and debugging a functional-style program is easier."
msgstr ""
"La programmation fonctionnelle simplifie les processus de test et de debug."

#: ../Doc/howto/functional.rst:150
msgid ""
"Debugging is simplified because functions are generally small and clearly "
"specified.  When a program doesn't work, each function is an interface point "
"where you can check that the data are correct.  You can look at the "
"intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"Les fonctions sont généralement courtes et clairement spécifiées, ce qui "
"simplifie le debug. Quand un programme ne fonctionne pas, chaque fonction "
"est un point d'interface où l'on peut vérifier si la donnée produite en "
"sortie est correcte. On peut aussi voir les entrées et les sorties "
"intermédiaires pour isoler rapidement la fonction responsable d'un bug."

#: ../Doc/howto/functional.rst:155
msgid ""
"Testing is easier because each function is a potential subject for a unit "
"test. Functions don't depend on system state that needs to be replicated "
"before running a test; instead you only have to synthesize the right input "
"and then check that the output matches expectations."
msgstr ""
"Les tests sont simplifiés car chaque fonction est potentiellement sujette à "
"un test unitaire. Les fonctions ne dépendent pas de l'état d'un système qui "
"doit être répliqué avant d'exécuter un test; on doit plutôt synthétiser les "
"entrées correctes et vérifier qu'elles correspondent aux sorties attendues."

#: ../Doc/howto/functional.rst:162
msgid "Composability"
msgstr "Composabilité"

#: ../Doc/howto/functional.rst:164
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will be "
"unavoidably specialized to a particular application, but others will be "
"useful in a wide variety of programs.  For example, a function that takes a "
"directory path and returns all the XML files in the directory, or a function "
"that takes a filename and returns its contents, can be applied to many "
"different situations."
msgstr ""
"En travaillant sur un programme rédigé de façon fonctionnelle, vous écrirez "
"beaucoup de fonctions avec des entrées et des sorties variables. Certaines "
"de ces fonctions seront inévitablement spécialisées pour une certaine "
"application, mais d'autres seront utiles dans de futurs programmes. Par "
"exemple, une fonction qui prend le chemin d'un dossier et renvoie tous les "
"fichiers XML dans ce dossier, ou une fonction qui prend un fichier en "
"paramètre et renvoie son contenu, peut être utilisé dans de nombreux cas de "
"figure."

#: ../Doc/howto/functional.rst:171
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new configuration "
"and writing a few functions specialized for the current task."
msgstr ""
"Avec le temps, vous créerez une librairie personnelle de fonctions utiles. "
"Vous assemblerez de nouveaux programmes en arrangeant vos fonctions d'une "
"nouvelle façon et en en écrivant d'autres plus spécialisées dans la tâche "
"actuelle."

#: ../Doc/howto/functional.rst:179
msgid "Iterators"
msgstr "Itérateurs"

#: ../Doc/howto/functional.rst:181
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"Je vais commencer par montrer une fonctionnalité de Python qui est un point "
"important pour écrire des programmes dans un style fonctionnel: Les "
"itérateurs."

#: ../Doc/howto/functional.rst:184
msgid ""
"An iterator is an object representing a stream of data; this object returns "
"the data one element at a time.  A Python iterator must support a method "
"called :meth:`~iterator.__next__` that takes no arguments and always returns "
"the next element of the stream.  If there are no more elements in the "
"stream, :meth:`~iterator.__next__` must raise the :exc:`StopIteration` "
"exception. Iterators don't have to be finite, though; it's perfectly "
"reasonable to write an iterator that produces an infinite stream of data."
msgstr ""
"Un itérateur est un objet qui représente un flux de données: cet objet "
"renvoie les données, un élément à la fois. Un itérateur Python doit "
"implémenter une méthode appelée :meth:`~iterator.__next__` qui ne prend "
"aucun argument et renvoie toujours l'élément suivant de ce flot. S'il n'y a "
"plus d'éléments dans le flot, :meth:~iterator.__next__` doit lever "
"l'excpetion :exc:`StopIteration`. Les itérateurs ne doivent pas forcément "
"être finis; Il est parfaitement acceptable d'écrire un itérateur qui produit "
"un flot de données ininterrompu."

#: ../Doc/howto/functional.rst:192
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to "
"return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  Several "
"of Python's built-in data types support iteration, the most common being "
"lists and dictionaries.  An object is called :term:`iterable` if you can get "
"an iterator for it."
msgstr ""
"La fonction native :func:`iter` prend un objet arbitraire et essaye de "
"renvoyer un itérateur qui renverra les éléments de l'objet et lève "
"l'exception :exc:`TypeError` si l'on ne peut pas itérer sur l'objet. "
"Plusieurs types natifs de Python prennent en charge l'itération. les plus "
"communs étant les listes et les dictionnaires. Un objet est dit :term:"
"`iterable` si l'on peut en obtenir un itérateur."

#: ../Doc/howto/functional.rst:199
msgid "You can experiment with the iteration interface manually:"
msgstr "Vous pouvez expérimenter avec les itérateurs manuellement:"

#: ../Doc/howto/functional.rst:217
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X in "
"Y``, Y must be an iterator or some object for which :func:`iter` can create "
"an iterator.  These two statements are equivalent::"
msgstr ""
"Python s'attend à trouver des objets itérables dans des contextes variés, le "
"plus important étant la boucle :keyword:`for`.Dans la boucle ``for X in Y``, "
"Y doit être un itérateur ou un objet pour lequel :func:`iter` doit pouvoir "
"créer un itérateur. Ces deux déclarations sont équivalentes::"

#: ../Doc/howto/functional.rst:229
msgid ""
"Iterators can be materialized as lists or tuples by using the :func:`list` "
"or :func:`tuple` constructor functions:"
msgstr ""
"Les itérateurs peuvent être matérialisés par des listes ou des n-uplet en "
"utilisant les constructeurs :func:`list` ou :func:`tuple`:"

#: ../Doc/howto/functional.rst:238
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"La déconstruction prend aussi en charge les itérateurs: Si vous savez qu'un "
"itérateur renvoie N éléments, vous pouvez les dépaqueter dans un N-uplet:"

#: ../Doc/howto/functional.rst:247
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The ``"
"\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator.  "
"You'll run into obvious problems if the iterator is infinite; :func:`max`, :"
"func:`min` will never return, and if the element X never appears in the "
"stream, the ``\"in\"`` and ``\"not in\"`` operators won't return either."
msgstr ""
"Les fonctions natives tel que :func:`max` et :func:`min` peuvent prendre un "
"seul itérateur en argument et renvoyer l'élément le plus important ou le "
"plus petit. Les opérateurs ``\"in\"`` et ``\"not in\"`` prennent aussi en "
"charge les itérateurs: ``X in iterator`` est vrai si X est trouvé dans le "
"flux renvoyé par l'itérateur. Vous rencontrerez des problèmes évidents si "
"l'itérateur est infini; :func:`max`, :func:`min` ne renverront jamais, et si "
"l'élément X n'apparaît jamais dans le flot, les opérateurs ``\"in\"`` et ``"
"\"not in\"`` ne renverront jamais non plus."

#: ../Doc/howto/functional.rst:255
msgid ""
"Note that you can only go forward in an iterator; there's no way to get the "
"previous element, reset the iterator, or make a copy of it.  Iterator "
"objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to create a "
"new iterator."
msgstr ""
"Veuillez noter qu'un itérateur ne peut qu'avancer; il n'y a aucun moyen "
"d'obtenir l'élément précédent, de réinitialiser l'itérateur ou d'en faire "
"une copie. Certains itérateurs peuvent optionnellement fournir ces capacités "
"supplémentaires, mais le protocole des itérateurs ne spécifie que la "
"méthode :meth:`~iterator.__next__`. Les fonctions peuvent donc consommer "
"entièrement la sortie de l'itérateur; et si vous devez faire quelque chose "
"d'autre avec ce même flux, vous devrez créer un nouvel itérateur."

#: ../Doc/howto/functional.rst:265
msgid "Data Types That Support Iterators"
msgstr "Les Types de Données qui prennent en charge les Itérateurs"

#: ../Doc/howto/functional.rst:267
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support creation "
"of an iterator."
msgstr ""
"Nous avons déjà vu comment les listes et les n-uplet gèrent les itérateurs. "
"En réalité, n'importe quel type séquentiel Python; tel que les chaînes de "
"caractère, prennent automatiquement en charge la création d'itérateurs."

#: ../Doc/howto/functional.rst:271
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop over "
"the dictionary's keys::"
msgstr ""
"Appeler :func:`iter` sur un dictionnaire renvoie un itérateur qui boucle sur "
"les clés dudit dictionnaire::"

#: ../Doc/howto/functional.rst:291
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is guaranteed "
"to be the same as the insertion order. In earlier versions, the behaviour "
"was unspecified and could vary between implementations."
msgstr ""
"Notez qu'à partir de Pyhton 3.7, l'ordre d'itération sur un dictionnaire est "
"garanti d'être le même que celui d'insertion. Sur les versions précédentes, "
"le comportement n'était pas défini et pouvait varier selon les "
"implémentations."

#: ../Doc/howto/functional.rst:295
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the :meth:"
"`~dict.values` or :meth:`~dict.items` methods to get an appropriate iterator."
msgstr ""
"Appeler :func:`iter` sur un dictionnaire boucle toujours sur les clés, mais "
"les dictionnaires disposent d'autres méthodes qui renvoient d'autres "
"itérateurs. Si vous voulez boucler sur les valeurs ou sur les paires clé/"
"valeur, vous pouvez appeler explicitement les méthodes :meth:`~dict.values` "
"ou :meth:`dict.items` pour obtenir l'itérateur approprié."

#: ../Doc/howto/functional.rst:301
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite "
"stream of ``(key, value)`` tuples:"
msgstr ""
"Le constructeur :func:`dict` peut accepter un itérateur qui renvoie un flux "
"fini de n-uplet ``(clé, valeur)`` :"

#: ../Doc/howto/functional.rst:308
msgid ""
"Files also support iteration by calling the :meth:`~io.TextIOBase.readline` "
"method until there are no more lines in the file.  This means you can read "
"each line of a file like this::"
msgstr ""
"Les fichiers supportent aussi l'itération en appelant la méthode :meth:`~io."
"TextIOBase.readline` jusqu'à ce qu'il n'y ait plus de lignes dans le "
"fichier. Cela signifie que vous pouvez lire chaque ligne d'un fichier comme "
"ceci::"

#: ../Doc/howto/functional.rst:316
msgid ""
"Sets can take their contents from an iterable and let you iterate over the "
"set's elements::"
msgstr ""
"Les ensembles peuvent aussi prendre leur contenu depuis un itérable et vous "
"laisser itérer sur leurs éléments::"

#: ../Doc/howto/functional.rst:326
msgid "Generator expressions and list comprehensions"
msgstr "Expressions génératrices et compréhensions de liste"

#: ../Doc/howto/functional.rst:328
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"Deux opérations fréquentes sur la sortie d'un itérateur sont 1) d'effectuer "
"une opération sur chaque élément 2) de séléctionner un sous-ensemble "
"d'éléments qui remplissent certaines conditions. Par exemple, avec une liste "
"de chaînes données, on peut vouloir enlever les espaces en fin de ligne ou "
"ne garder que les chaînes contenant une sous-chaîne donnée."

#: ../Doc/howto/functional.rst:334
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" and "
"\"genexps\") are a concise notation for such operations, borrowed from the "
"functional programming language Haskell (https://www.haskell.org/).  You can "
"strip all the whitespace from a stream of strings with the following code::"
msgstr ""
"Les compréhensions de liste et les expressions génératrices (abrégés en "
"\"listcomps\" et \"genexps\") sont une notation concise pour de telles "
"opérations, elles ont été empruntées au langage fonctionnel Haskell (https://"
"www.haskell.org/). On peut supprimer tous les espaces blancs d'un flux de "
"chaînes avec le code suivant::"

#: ../Doc/howto/functional.rst:347
msgid ""
"You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"On peut séléctionner seulement certains éléments en ajoutant une condition ``"
"\"if\"``::"

#: ../Doc/howto/functional.rst:352
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` is "
"a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not "
"needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return an "
"infinite stream or a very large amount of data.  Generator expressions are "
"preferable in these situations."
msgstr ""
"Une compréhension de liste nous renvoie une liste Python; ``stripped_list`` "
"est une liste contenant les lignes renvoyées et non un itérateur. Les "
"expressions génératrices renvoient un itérateur qui calculent les valeurs si "
"nécéssaires, sans avoir besoin de toutes les matérialiser à la fois. Cela "
"signifie que les compréhensions de liste n'ont pas d'intérêt si l'on "
"travaille avec des itérateurs renvoyant un flux infini ou une importante "
"quantité de données. Les expressions génératrices sont alors préférables "
"dans ces situations."

#: ../Doc/howto/functional.rst:359
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"Les expressions génératrices sont contenues dans des parenthèses (\"()\") et "
"les compréhensions de liste dans des crochets (\"[]\"). Les expressions "
"génératrices ont la forme::"

#: ../Doc/howto/functional.rst:372
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"Ici encore, pour une compréhension de liste, seuls les crochets extérieurs "
"sont différents (crochets au lieu de parenthèses)"

#: ../Doc/howto/functional.rst:375
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when ``condition`` "
"is true."
msgstr ""
"Les éléments de la sortie générée seront les valeurs successives de "
"l'``expression``. Les clauses de la condition ``if``  sont optionnelles; si "
"elle est présente, l'``expresssion`` est seulement évaluée et ajoutée au "
"résultat lorsque la condition est vérifiée."

#: ../Doc/howto/functional.rst:379
msgid ""
"Generator expressions always have to be written inside parentheses, but the "
"parentheses signalling a function call also count.  If you want to create an "
"iterator that will be immediately passed to a function you can write::"
msgstr ""
"Les expressions génératrices doivent toujours être écrites à l'intérieur de "
"parenthèses, mais les parenthèses d'un appel à fonction peuvent aussi "
"compter. Si l'on veut créer un itérateur qui sera immédiatement passé à une "
"fonction, on peut écrire::"

#: ../Doc/howto/functional.rst:385
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated over "
"from left to right, **not** in parallel.  For each element in ``sequence1``, "
"``sequence2`` is looped over from the beginning.  ``sequence3`` is then "
"looped over for each resulting pair of elements from ``sequence1`` and "
"``sequence2``."
msgstr ""
"Les clauses ``for...in`` contiennent les séquences qui seront itérées. Ces "
"séquences ne doivent pas forcément être de la même longueur, car elles sont "
"parcourues de gauche à droite; **non** en parallèle. Pour chaque élément "
"dans ``sequence1``, ``sequence2`` est reparcouru depuis le début. "
"``sequence3`` est alors itéré pour chaque paire résultant des éléments "
"combinés de ``sequence1`` et de ``sequence2``."

#: ../Doc/howto/functional.rst:391
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"Pour le dire d'une autre façon, une compréhension de liste ou une expression "
"génératrice est équivalente au code Python suivant::"

#: ../Doc/howto/functional.rst:408
msgid ""
"This means that when there are multiple ``for...in`` clauses but no ``if`` "
"clauses, the length of the resulting output will be equal to the product of "
"the lengths of all the sequences.  If you have two lists of length 3, the "
"output list is 9 elements long:"
msgstr ""
"Cela signifie que pour plusieurs ``for...in`` conditions sans ``if``, la "
"longueur de la sortie correspondra au produit des longeurs de toutes les "
"séquences. Si l'on a deux listes de longueur 3 alors la sortie comportera 9 "
"éléments:"

#: ../Doc/howto/functional.rst:420
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if ``expression`` "
"is creating a tuple, it must be surrounded with parentheses.  The first list "
"comprehension below is a syntax error, while the second one is correct::"
msgstr ""
"Pour éviter d'introduire une ambiguïté dans la grammaire de Python, si "
"l'``expression`` crée un n-uplet, il doit être entouré de parenthèses. La "
"première compréhension de liste ci-dessous comporte une erreur de syntaxe "
"alors que la seconde est correcte::"

#: ../Doc/howto/functional.rst:431
msgid "Generators"
msgstr "Générateurs"

#: ../Doc/howto/functional.rst:433
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"Les générateurs sont un ensemble particulier de fonctions qui simplifie "
"l'écriture d'itérateurs. Les fonctions usuelles calculent une valeur et la "
"renvoient, tandis que les générateurs renvoient un itérateur qui lui-même "
"renvoie un flux de données."

#: ../Doc/howto/functional.rst:437
msgid ""
"You're doubtless familiar with how regular function calls work in Python or "
"C. When you call a function, it gets a private namespace where its local "
"variables are created.  When the function reaches a ``return`` statement, "
"the local variables are destroyed and the value is returned to the caller.  "
"A later call to the same function creates a new private namespace and a "
"fresh set of local variables. But, what if the local variables weren't "
"thrown away on exiting a function?  What if you could later resume the "
"function where it left off?  This is what generators provide; they can be "
"thought of as resumable functions."
msgstr ""
"Vous êtes sans doute familier sur la façon d'appeler des fonctions en Python "
"ou en C. Lorsqu'on appelle une fonction, elle génère un espace privé où ses "
"variables locales sont créées. Au moment où la fonction atteint un "
"``return``, les variables locales sont détruites et la valeur est retournée "
"à la fonction appelante. Un appel ultérieur à cette même fonction crée un "
"nouvel espace privé et un nouvel ensemble de variables locales. Mais si les "
"variables locales n'étaient pas détruites à la fin de cette fonction ? Si "
"l'exécution de cette fonction reprenait à l'endroit où elle était restée ? "
"C'est le rôle que les générateurs remplissent; On peut les imaginer comme "
"des fonctions interruptibles."

#: ../Doc/howto/functional.rst:446
msgid "Here's the simplest example of a generator function:"
msgstr "Voici le plus simple exemple d'un générateur:"

#: ../Doc/howto/functional.rst:452
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator function; "
"this is detected by Python's :term:`bytecode` compiler which compiles the "
"function specially as a result."
msgstr ""
"Chaque fonction contenant le mot-clé :keyword:`yield` est un générateur; "
"c'est détecté par le compilateur de :term:`bytecode` Python qui va en "
"conséquence compiler la fonction différement."

#: ../Doc/howto/functional.rst:456
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator protocol.  "
"On executing the ``yield`` expression, the generator outputs the value of "
"``i``, similar to a ``return`` statement.  The big difference between "
"``yield`` and a ``return`` statement is that on reaching a ``yield`` the "
"generator's state of execution is suspended and local variables are "
"preserved.  On the next call to the generator's :meth:`~generator.__next__` "
"method, the function will resume executing."
msgstr ""
"L'appel d'un générateur ne renvoie pas une simple valeur; il renvoie plutôt "
"un objet qui suporte le protocole des itérateurs. Lors de l'exécution de "
"l'expression ``yield``, le générateur retourne ``i``, qui est similaire à un "
"``return``. La grande différence entre un ``yield`` et un ``return`` réside "
"dans le fait qu'un appel à `` yield`` préserve l'état du générateur et les "
"variables locales sont conservées. Au prochain appel de la méthode :meth:"
"`~generator.__next__` du générateur, la fonction reprendra son exécution."

#: ../Doc/howto/functional.rst:465
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "Voici un exemple d'utilisation pour le générateur ``generate_ints()``:"

#: ../Doc/howto/functional.rst:482
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"On peut également écrire ``for i in generate_ints(5)``, ou ``a,b,c = "
"generate_ints(3)``."

#: ../Doc/howto/functional.rst:485
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the :meth:`~generator.__next__` "
"method.  Once this happens, or the bottom of the function is reached, the "
"procession of values ends and the generator cannot yield any further values."
msgstr ""
"A l'intérieur d'un générateur, ``return value`` lève l'exception "
"``StopIteration(value)`` depuis la méthode :meth:`~generator.__next__`. "
"Après cela, ou une fois que la fin de la fonction est atteinte, le "
"traitement des valeurs prend fin et le générateur ne peut plus renvoyer de "
"nouvelles valeurs."

#: ../Doc/howto/functional.rst:490
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"On peut aussi obtenir l'effet des générateurs manuellement en écrivant nos "
"propres classes et en sauvegardant les variables locales du générateur comme "
"des variables d'instance. Par exemple, on peut renvoyer une liste d'entiers "
"en assignant ``self.count`` à 0 dans un premier temps et en le faisant "
"incrémenter et renvoyer par `` la méthode :meth:`~iterator.__next__` après "
"initialisation. Cependant pour un générateur modérément plus compliqué, "
"écrire une classe équivalente peut devenir un vrai casse-tête."

#: ../Doc/howto/functional.rst:498
msgid ""
"The test suite included with Python's library, :source:`Lib/test/"
"test_generators.py`, contains a number of more interesting examples.  Here's "
"one generator that implements an in-order traversal of a tree using "
"generators recursively. ::"
msgstr ""
"La suite de tests incluse dans la librairie de Python, :source:`Lib/test/"
"test_generators.py`, contient d'autres exemples intéréssants. Voici un "
"générateur qui implémente la traversée infixe d'un arbre en utilisant les "
"générateurs récursivement. ::"

#: ../Doc/howto/functional.rst:514
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the N-"
"Queens problem (placing N queens on an NxN chess board so that no queen "
"threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"Deux autres exemples dans ``test_generators.py`` produisent des solutions "
"pour le problème des N-dames (placer N dames sur un plateau d'échecs de "
"dimensions NxN de telle façon qu'aucune dame n'en menace une autre) ou celui "
"du Cavalier (trouver le chemin que prend un cavalier pour chaque case d'un "
"plateau de dimensions NxN sans revisiter de case une seconde fois)."

#: ../Doc/howto/functional.rst:522
msgid "Passing values into a generator"
msgstr "Passer des valeurs à un générateur"

#: ../Doc/howto/functional.rst:524
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to pass "
"any new information into the function when its execution is resumed.  You "
"could hack together this ability by making the generator look at a global "
"variable or by passing in some mutable object that callers then modify, but "
"these approaches are messy."
msgstr ""
"Dans Python 2.4 et ses versions précédentes, les générateurs ne pouvaient "
"produire qu'une sortie simple. Une fois que le code d'un générateur était "
"appelé, il n'y avait aucun moyen de passer de nouvelles informations dans la "
"fonction quand son exécution reprenait. On pouvait simuler ce comportement "
"en faisant ressembler le générateur à une variable globale ou en passant un "
"objet mutable que les fonctions appelantes modifiaient a posteriori, mais "
"ces approches étaient complexes et imparfaites."

#: ../Doc/howto/functional.rst:531
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. :keyword:"
"`yield` became an expression, returning a value that can be assigned to a "
"variable or otherwise operated on::"
msgstr ""
"A partir de Pyhon 2.5, une façon simple de passer des valeurs à un "
"générateur est apparu, :keyword:`yield` devient une expression, retournant "
"une valeur qui peut-être assignée ou réutilisée pour une opération::"

#: ../Doc/howto/functional.rst:537
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the "
"above example. The parentheses aren't always necessary, but it's easier to "
"always add them instead of having to remember when they're needed."
msgstr ""
"Je vous recommande de **toujours** mettre des parenthèses autour d'un "
"``yield`` si vous utilisez la valeur de retour pour une opération, comme "
"dans l'exemple ci-dessus. Les parenthèses ne sont pas toujours nécéssaires, "
"mais il est plus simple de les mettre à chaque fois plutôt que de se "
"rappeler quand elles sont nécéssaires."

#: ../Doc/howto/functional.rst:542
msgid ""
"(:pep:`342` explains the exact rules, which are that a ``yield``-expression "
"must always be parenthesized except when it occurs at the top-level "
"expression on the right-hand side of an assignment.  This means you can "
"write ``val = yield i`` but have to use parentheses when there's an "
"operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` explique les règles exactes, à savoir qu'une expression "
"``yield`` doit toujours être parenthésée sauf quand elle est la seule "
"expression du côté droit d'une assignation. On peut donc écrire ``val = "
"yield i`` mais on doit mettre des parenthèses en présence d'une opération "
"comme dans ``val = (yield i) + 12``.)"

#: ../Doc/howto/functional.rst:548
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and the "
"``yield`` expression returns the specified value.  If the regular :meth:"
"`~generator.__next__` method is called, the ``yield`` returns ``None``."
msgstr ""
"Les valeurs sont passées au générateur en appelant sa méthode :meth:"
"`send(value)<generator.send>`. Celle-ci reprend l'exécution du code du "
"générateur et le ```yield`` renvoie la valeur passée. Si la méthode "
"ordinaire :meth:`~generator.__next__` est appelée, le ``yield`` renvoie "
"``None``."

#: ../Doc/howto/functional.rst:553
msgid ""
"Here's a simple counter that increments by 1 and allows changing the value "
"of the internal counter."
msgstr ""
"Voici un simple compteur qui incrémente de 1 et permet le changement de la "
"valeur du compteur interne."

#: ../Doc/howto/functional.rst:568
msgid "And here's an example of changing the counter:"
msgstr "Et voici un exemple de changement du compteur:"

#: ../Doc/howto/functional.rst:585
msgid ""
"Because ``yield`` will often be returning ``None``, you should always check "
"for this case.  Don't just use its value in expressions unless you're sure "
"that the :meth:`~generator.send` method will be the only method used to "
"resume your generator function."
msgstr ""
"``yield`` renvoie souvent ``None``, en conséquence vous devriez toujours "
"tester cette valeur. N'utilisez pas juste la valeur de retour dans des "
"expressions à moins d'être certain que la méthode :meth:`~generator.send` "
"soit la seule méthode utilisée pour reprendre le cours du générateur."

#: ../Doc/howto/functional.rst:590
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ""
"Deux autres méthodes sur les générateurs viennent compléter :meth:"
"`~generator.send`:"

#: ../Doc/howto/functional.rst:593
msgid ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` is used to "
"raise an exception inside the generator; the exception is raised by the "
"``yield`` expression where the generator's execution is paused."
msgstr ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` est "
"utilisée pour lever une exception depuis un générateur; l'exception est "
"levée depuis un ``yield`` où l'exécution du générateur est pausée."

#: ../Doc/howto/functional.rst:597
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside the "
"generator to terminate the iteration.  On receiving this exception, the "
"generator's code must either raise :exc:`GeneratorExit` or :exc:"
"`StopIteration`; catching the exception and doing anything else is illegal "
"and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close` will also "
"be called by Python's garbage collector when the generator is garbage-"
"collected."
msgstr ""
":meth:`~generator.close` lève une exception :exc:`GeneratorExit` à "
"l'intérieur du générateur pour interrompre l'itération. Après interception "
"de cette exception, le code du générateur doit soit lever :exc:"
"`GeneratorExit` soit :exc:`StopIteration`; intercepter cette exception et "
"faire quoi que ce soit d'autre est illégal et déclenchera une :exc:"
"`RuntimeError`. :meth:`~generator.close` sera aussi appelé par le ramasse-"
"miettes de Python quand le générateur sera détruit."

#: ../Doc/howto/functional.rst:605
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching :exc:"
"`GeneratorExit`."
msgstr ""
"Si vous devez lancer du code de nettoyage après une :exc:`GeneratorExit`, Je "
"suggère l'utilisation de la structure ``try: ... finally`` plutôt que "
"d'intercepter :exc:`GeneratorExit`."

#: ../Doc/howto/functional.rst:608
msgid ""
"The cumulative effect of these changes is to turn generators from one-way "
"producers of information into both producers and consumers."
msgstr ""
"Les effets cumulés de ces changements ont transformé les générateurs de "
"simples producteurs d'information en producteurs et consommateurs "
"d'informations."

#: ../Doc/howto/functional.rst:611
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but coroutines "
"can be entered, exited, and resumed at many different points (the ``yield`` "
"statements)."
msgstr ""
"Les générateurs deviennent aussi des **coroutines**, une forme généralisée "
"des sous-routines. Les sous-routines sont invoqués à un certain point et "
"terminées à un autre (le début de la fonction au premier ``return`` "
"rencontré), mais les coroutines peuvent être appelées, terminées et reprises "
"depuis plusieurs points différents (les ``yield``)."

#: ../Doc/howto/functional.rst:618
msgid "Built-in functions"
msgstr "Fonctions natives"

#: ../Doc/howto/functional.rst:620
msgid ""
"Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"Regardons plus en détail les fonctions natives souvent utilisées avec les "
"itérateurs."

#: ../Doc/howto/functional.rst:622
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` duplicate "
"the features of generator expressions:"
msgstr ""
"Deux fonctions natives de Python, :func:`map` et :func:`filter` réplique les "
"fonctionnalités des expressions génératrices:"

#: ../Doc/howto/functional.rst:634
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...)<map>` renvoie un itérateur sur la séquence"

#: ../Doc/howto/functional.rst:626
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), ...``."

#: ../Doc/howto/functional.rst:636
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "On peut aussi arriver au même effet avec une compréhension de liste."

#: ../Doc/howto/functional.rst:638
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the "
"sequence elements that meet a certain condition, and is similarly duplicated "
"by list comprehensions.  A **predicate** is a function that returns the "
"truth value of some condition; for use with :func:`filter`, the predicate "
"must take a single value."
msgstr ""
":func:`filter(predicate, iter)<filter>` renvoie un itérateur sur toute la "
"séquence d'éléments remplissant une certaine condition, et est similairement "
"répliqué par les compréhensions de liste. Un **prédicat** est une fonction "
"qui renvoie si une condition est vérifiée ou non; Pour être utilisé avec :"
"func:`filter`, le prédicat doit prendre une seule valeur."

#: ../Doc/howto/functional.rst:651
msgid "This can also be written as a list comprehension:"
msgstr ""
"Cela peut aussi bien être écrit sous la forme d'une compréhension de listes:"

#: ../Doc/howto/functional.rst:657
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in the "
"iterable returning 2-tuples containing the count (from *start*) and each "
"element. ::"
msgstr ""
":func:`enumerate(iter, start=0)<enumerate>` décompte les éléments de "
"l'itérable en retournant un doublet contenant l'index (depuis *start*) "
"associé à chaque élément. ::"

#: ../Doc/howto/functional.rst:667
msgid ""
":func:`enumerate` is often used when looping through a list and recording "
"the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` est souvent utilisé lors d'une itération sur liste pour "
"sauvegarder les index d'éléments remplissant certaines conditions::"

#: ../Doc/howto/functional.rst:675
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all the "
"elements of the iterable into a list, sorts the list, and returns the sorted "
"result.  The *key* and *reverse* arguments are passed through to the "
"constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False)<sorted>` collecte tous les "
"éléments d'un itérable dans une liste, trie cette liste et renvoie le "
"résultat trié. Les arguments *key*  et *reverse* sont passés à la liste "
"construite via la méthode :meth:`~list.sort`. ::"

#: ../Doc/howto/functional.rst:690
msgid ""
"(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"(Pour une discussion plus en profondeur sur le tri, voir :ref:"
"`sortinghowto`.)"

#: ../Doc/howto/functional.rst:693
#, fuzzy
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at "
"the truth values of an iterable's contents.  :func:`any` returns ``True`` if "
"any element in the iterable is a true value, and :func:`all` returns "
"``True`` if all of the elements are true values:"
msgstr ""
"Les fonctions natives :func:`any(iter)<any>` et :func:`all(iter)<all>` "
"regarde la *truthiness* du contenu d'un itérable. :func:`any` renvoie "
"``True`` si au moins un élément de l'itérable est une valeur vraie, et :func:"
"`all` renvoie ``True`` si tous les éléments sont des valeurs vraies:"

#: ../Doc/howto/functional.rst:712
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable "
"and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...)<zip>` prend un élément de chaque itérable et "
"les retourne sous forme de n-uplet::"

#: ../Doc/howto/functional.rst:718
msgid ""
"It doesn't construct an in-memory list and exhaust all the input iterators "
"before returning; instead tuples are constructed and returned only if "
"they're requested.  (The technical term for this behaviour is `lazy "
"evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"Les N-uplet sont construits seulement quand ils sont demandés par "
"l'utilisateur plutôt que de créer une liste complète qui est à peu à peu "
"épuisée par une suite d'appels successifs. (On appelle ce comportement la "
"`lazy evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"

#: ../Doc/howto/functional.rst:723
msgid ""
"This iterator is intended to be used with iterables that are all of the same "
"length.  If the iterables are of different lengths, the resulting stream "
"will be the same length as the shortest iterable. ::"
msgstr ""
"Cet itérateur est prévu pour être utilisé avec des itérables de même "
"longueur. Si les itérables sont de différentes longueurs, le flux résultant "
"sera de la même longueur que le plus court itérable. ::"

#: ../Doc/howto/functional.rst:730
msgid ""
"You should avoid doing this, though, because an element may be taken from "
"the longer iterators and discarded.  This means you can't go on to use the "
"iterators further because you risk skipping a discarded element."
msgstr ""
"Vous devriez éviter ce comportement, néanmoins, car un élément peut être "
"extrait de l'itérable le plus long et être ignoré. Cela signifie que les "
"itérateurs ne pourront plus être utilisés par la suite à cause du risque de "
"passer un élément déjà ignoré."

#: ../Doc/howto/functional.rst:736
msgid "The itertools module"
msgstr "Le module itertools"

#: ../Doc/howto/functional.rst:738
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators as "
"well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
"Le module :mod:`itertools` contient un certain nombre d'itérateurs "
"communément utilisés ainsi que des fonctions pour combiner plusieurs "
"itérateurs. Cette section introduira le contenu du module à l'aide de petits "
"exemples."

#: ../Doc/howto/functional.rst:742
msgid "The module's functions fall into a few broad classes:"
msgstr "Les fonctions du module se divisent en quelques grandes classes:"

#: ../Doc/howto/functional.rst:744
msgid "Functions that create a new iterator based on an existing iterator."
msgstr ""
"Les fonctions qui créent un nouvel itérateur depuis un itérateur existant."

#: ../Doc/howto/functional.rst:745
msgid "Functions for treating an iterator's elements as function arguments."
msgstr ""
"Les fonctions pour manipuler les éléments d'un itérateur comme des arguments "
"d'une fonction."

#: ../Doc/howto/functional.rst:746
msgid "Functions for selecting portions of an iterator's output."
msgstr ""
"Les fonctions pour sélectionner des portions de la sortie d'un itérateur."

#: ../Doc/howto/functional.rst:747
msgid "A function for grouping an iterator's output."
msgstr "Une fonction pour grouper la sortie d'un itérateur."

#: ../Doc/howto/functional.rst:750
msgid "Creating new iterators"
msgstr "Créer de nouveaux itérateurs"

#: ../Doc/howto/functional.rst:752
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an infinite "
"stream of evenly spaced values.  You can optionally supply the starting "
"number, which defaults to 0, and the interval between numbers, which "
"defaults to 1::"
msgstr ""
":func:`itertools.count(start, step)<itertools.count>` renvoie un flux infini "
"de valeurs séparées par le pas donné (1 par défaut). On peut aussi spécifier "
"la valeur de départ (0 par défaut)::"

#: ../Doc/howto/functional.rst:763
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the contents "
"of a provided iterable and returns a new iterator that returns its elements "
"from first to last.  The new iterator will repeat these elements "
"infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter)<itertools.cycle>` sauve une copie du contenu "
"d'un itérable passé en paramètre et renvoie un nouvel itérateur qui renvoie "
"ses éléments du premier au dernier. Le nouvel itérateur répète ces éléments "
"à l'infini. ::"

#: ../Doc/howto/functional.rst:770
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the provided "
"element *n* times, or returns the element endlessly if *n* is not "
"provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n])<itertools.repeat>`  renvoie l'élément "
"passé *n* fois ou renvoie l'élément sans fin si aucun *n* n'est passé. ::"

#: ../Doc/howto/functional.rst:778
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of the "
"first iterator, then all the elements of the second, and so on, until all of "
"the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...)<itertools.chain>` prend un nombre "
"arbitraire d'itérables en entrée, et renvoie tous les éléments du premier "
"itérateur, puis tous les éléments du second, et ce jusqu'à ce que tous les "
"itérables aient été parcourus. ::"

#: ../Doc/howto/functional.rst:786
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a value "
"for *step*, elements will be skipped accordingly.  Unlike Python's string "
"and list slicing, you can't use negative values for *start*, *stop*, or "
"*step*. ::"
msgstr ""
":func:`itertools.isslice(iter, [start], stop, [step])<itertools.isslice>` "
"renvoie un flux qui est une portion de l'itérateur. Avec un seul argument "
"*stop*, il renverra les *stop* premiers éléments. Si on fournit un index de "
"départ, on obtient *stop-start* éléments et si on fournit une valeur en tant "
"que *step*, des éléments seront passés à chaque itération. Contrairement aux "
"chaînes Python et à la découpe de listes, *start*, *stop* et *step* ne "
"peuvent être négatives. ::"

#: ../Doc/howto/functional.rst:800
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; it "
"returns *n* independent iterators that will all return the contents of the "
"source iterator. If you don't supply a value for *n*, the default is 2.  "
"Replicating iterators requires saving some of the contents of the source "
"iterator, so this can consume significant memory if the iterator is large "
"and one of the new iterators is consumed more than the others. ::"
msgstr ""
":func:`itertools.tee(iter, [n])<itertools.tee>` réplique un itérateur; il "
"renvoie *n* itérateurs indépendants qui retourneront tous le contenu de "
"l'itérateur source. Si aucune valeur n'est donnée à *n*, elle est affectée "
"par défaut à 2. Répliquer des itérateurs nécéssite de sauvegarder le contenu "
"de l'itérateur source, cela peut consommer beaucoup de mémoire si "
"l'itérateur est important et que l'un des nouvels itérateurs est plus "
"souvent consommé que les autres. ::"

#: ../Doc/howto/functional.rst:819
msgid "Calling functions on elements"
msgstr "Appeler des fonctions sur des éléments"

#: ../Doc/howto/functional.rst:821
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) <operator."
"add>` (adds two values), :func:`operator.ne(a, b)  <operator.ne>` (same as "
"``a != b``), and :func:`operator.attrgetter('id') <operator.attrgetter>` "
"(returns a callable that fetches the ``.id`` attribute)."
msgstr ""
"Le module :mod:`operator` contient un ensemble de fonctions correspondant "
"aux opérateurs Python. On retrouve par exemple :func:`operator.add(a, "
"b)<operator.add>` qui ajoute deux valeurs, :func:`operator.ne(a, b)<operator."
"ne>` (pareil que ``a != b``) et :func:`operator.attrgetter('id')<operator."
"attrgetter>` (renvoie un membre appelable qui récupère l'attribut ``.id``)."

#: ../Doc/howto/functional.rst:827
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that the "
"iterable will return a stream of tuples, and calls *func* using these tuples "
"as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter)<itertools.starmap>`  suppose que "
"l'itérable renverra un flux de N-uplet, et appellera *func* utilisant chaque "
"N-uplet comme ensemble d'arguments à passer::"

#: ../Doc/howto/functional.rst:839
msgid "Selecting elements"
msgstr "Sélectionner des éléments"

#: ../Doc/howto/functional.rst:841
msgid ""
"Another group of functions chooses a subset of an iterator's elements based "
"on a predicate."
msgstr ""
"Un autre groupe de fonctions choisit un sous-ensemble des éléments renvoyé "
"par un itérateur en fonction d'un prédicat."

#: ../Doc/howto/functional.rst:844
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is "
"the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter)<itertools.filterfalse>` est "
"l'opposé de :func:`filter`, il retourne tous les éléments pour lesquels le "
"prédicat n'est pas vérifié::"

#: ../Doc/howto/functional.rst:851
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` returns "
"elements for as long as the predicate returns true.  Once the predicate "
"returns false, the iterator will signal the end of its results. ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter)<itertools.takewhile>` renvoie "
"les éléments tant que le prédicat est vérifié. Dès que le prédicat est faux, "
"l'itérateur s'arrête de renvoyer des éléments. ::"

#: ../Doc/howto/functional.rst:864
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` discards "
"elements while the predicate returns true, and then returns the rest of the "
"iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter)<itertools.dropwhile>` passe les "
"éléments tant que le prédicat est vérifié et les renvoie dès qu'il ne l'est "
"plus. ::"

#: ../Doc/howto/functional.rst:874
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes two "
"iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either one "
"is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors)<itertools.compress>` prend deux "
"itérateurs et renvoie seulement les éléments de *data* pour lesquels "
"l'élément correspondant dans *selectors* est vrai, s'arrêtant dès que l'un "
"des deux est épuisé::"

#: ../Doc/howto/functional.rst:883
msgid "Combinatoric functions"
msgstr "Fonctions combinatoires"

#: ../Doc/howto/functional.rst:885
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
"La fonction :func:`itertools.combinations(iterable, r)<itertools."
"combinations>` renvoie un itérateur donnant toutes les combinaisons "
"possibles *r* N-uplet des éléments contenus dans *iterable*. ::"

#: ../Doc/howto/functional.rst:900
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 in "
"the examples above.  A similar function, :func:`itertools."
"permutations(iterable, r=None) <itertools.permutations>`, removes this "
"constraint on the order, returning all possible arrangements of length *r*::"
msgstr ""
"Les éléments de chaque N-uplet restent dans le même ordre qu'*iterable* les "
"a renvoyé. Par exemple, le nombre 1 est toujours devant 2, 3, 4 ou 5 dans "
"les exemples ci-dessus. Une fonction similaire, :func:`itertools."
"permutations(iterable, r=None)<itertools.permutations>`, enlève cette "
"contrainte d'ordre, renvoyant tous les arrangements possibles de longueur "
"*r*::"

#: ../Doc/howto/functional.rst:919
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"Si aucune valeur n'est donnée à *r*, la longueur de l'itérable est utilisée, "
"cela implique que tous les éléments seront permutés."

#: ../Doc/howto/functional.rst:922
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"Ces fonctions produisent toutes les combinaisons possibles par position et "
"ne nécéssitent donc pas que le contenu d'*iterable* soit unique::"

#: ../Doc/howto/functional.rst:929
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"Le même triplet  ``('a', 'a', 'b')`` est présent deux fois, ,mais les deux "
"chaînes 'a' viennent de positions différentes."

#: ../Doc/howto/functional.rst:932
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) <itertools."
"combinations_with_replacement>` function relaxes a different constraint: "
"elements can be repeated within a single tuple.  Conceptually an element is "
"selected for the first position of each tuple and then is replaced before "
"the second element is selected.  ::"
msgstr ""
"La fonction :func:`itertools.combinations_with_replacement(iterable, "
"r)<itertools.combinations_with_replacement>` assouplit une autre contrainte: "
"les éléments peuvent être répétés dans un N-uplet. Conceptuellement un "
"élément est choisi pour la première position de chaque N-uplet et est "
"ensuite remplacé avant que le second élément soit choisi. ::"

#: ../Doc/howto/functional.rst:947
msgid "Grouping elements"
msgstr "Grouper des éléments"

#: ../Doc/howto/functional.rst:949
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, the "
"key is simply each element itself."
msgstr ""
"La dernière fonction dont nous discuterons, :func:`itertools.groupby(iter, "
"key_func=None)<itertools.groupby>`, est la plus compliquée. "
"``key_func(elem)`` est une fonction qui peut calculer une clé pour chaque "
"élément retourné par l'itérable. Si aucune fonction n'est fournie, chaque "
"clé est simplement l'élément lui-même."

#: ../Doc/howto/functional.rst:954
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the "
"underlying iterable that have the same key value, and returns a stream of 2-"
"tuples containing a key value and an iterator for the elements with that key."
msgstr ""
":func:`~itertools.groupby` collecte tous les éléments consécutifs de "
"l'itérable sous-jacent qui ont la même clé, et renvoie un flux de doublet "
"contenant une clé et un itérateur pour les éléments avec cette clé."

#: ../Doc/howto/functional.rst:982
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's contents "
"will already be sorted based on the key.  Note that the returned iterators "
"also use the underlying iterable, so you have to consume the results of "
"iterator-1 before requesting iterator-2 and its corresponding key."
msgstr ""
":func:`~itertools.groupby`  suppose que le contenu de l'itérable sous-jacent "
"sera déjà trié en fonction de la clé. On peut noter que les itérateurs "
"retournés utiliseront aussi l'itérable sous-jacent, vous devez donc "
"consommer les résultats de l'itérateur -1 avant de demander l'itérateur -2 "
"et sa clé correspondante."

#: ../Doc/howto/functional.rst:989
msgid "The functools module"
msgstr "Le module functools"

#: ../Doc/howto/functional.rst:991
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as input "
"and returns a new function.  The most useful tool in this module is the :"
"func:`functools.partial` function."
msgstr ""
"Le module :mod:`functools dans Python 2.5 contient des fonctions d'ordre "
"supérieur. Une **fonction d'ordre supérieur** prend une ou plusieurs "
"fonctions en entrée et renvoie une nouvelle fonction. L'outil le plus utile "
"de ce module est la fonction :func:`functools.partial`."

#: ../Doc/howto/functional.rst:996
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters "
"filled in. Consider a Python function ``f(a, b, c)``; you may wish to create "
"a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; you're "
"filling in a value for one of ``f()``'s parameters.  This is called "
"\"partial function application\"."
msgstr ""
"Pour des programmes écrits dans un style purement fonctionnel, on veut "
"parfois construire des variantes de fonctions déjà existantes qui ont des "
"paramètres par défaut. Prenons la fonction Python ``f(a, b, c)``; on "
"pourrait vouloir créer une nouvelle fonction ``g(b, c)`` qui équivaudrait à "
"``f(1, b, c)``; on remplit une valeur pour les paramètres de ``f()``. On "
"appelle cela \"application partielle de la fonction\"."

#: ../Doc/howto/functional.rst:1002
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke ``function`` "
"with the filled-in arguments."
msgstr ""
"Le constructeur de :func:`~functools.partial` prend les arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  L'objet "
"résultant est appelable; on peut l'appeler pour invoquer ``function`` avec "
"les arguments déjà remplis."

#: ../Doc/howto/functional.rst:1007
msgid "Here's a small but realistic example::"
msgstr "Voici un exemple court mais réaliste ::"

#: ../Doc/howto/functional.rst:1019
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a function "
"that takes two elements and returns a single value.  :func:`functools."
"reduce` takes the first two elements A and B returned by the iterator and "
"calculates ``func(A, B)``.  It then requests the third element, C, "
"calculates ``func(func(A, B), C)``, combines this result with the fourth "
"element returned, and continues until the iterable is exhausted.  If the "
"iterable returns no values at all, a :exc:`TypeError` exception is raised.  "
"If the initial value is supplied, it's used as a starting point and "
"``func(initial_value, A)`` is the first calculation. ::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value])<functools.reduce>` "
"effectue de manière cumulative une opération sur l'ensemble des éléments de "
"l'itérable (elle ne peut donc pas être utilisé sur des itérables infinis). "
"*func* doit être une fonction qui prend deux arguments et renvoie une seule "
"valeur.  :func:`functools.reduce` prend les deux premiers éléments A et B "
"renvoyés par l'itérateur et calcule ``func(A, B)``. Il récupère ensuite le "
"troisième élément, C, calcule ``func(func(A, B), C)``, combine le résultat "
"avec le quatrième élément et continue comme cela jusqu'à ce que l'itérable "
"soit épuisé. Si l'itérable ne retourne aucune valeur, une exception :exc:"
"`TypeError` est levée. Si une valeur initiale est fournie; elle est utilisée "
"comme point de départ et la première opération correspond à "
"``func(initial_value, A)``. ::"

#: ../Doc/howto/functional.rst:1043
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add up "
"all the elements of the iterable.  This case is so common that there's a "
"special built-in called :func:`sum` to compute it:"
msgstr ""
"Si vous utilisez :func:`operator.add` avec :func:`functools.reduce`, vous "
"allez additionner les éléments de l'itérable. Cette opération est tellement "
"courante qu'une fonction native dédiée existe: :func:`sum`:"

#: ../Doc/howto/functional.rst:1055
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to just "
"write the obvious :keyword:`for` loop::"
msgstr ""
"Il se peut néanmoins que pour beaucoup d'utilisations de :func:`functools."
"reduce`, l'usage d'une simple boucle :keyword:`for` soit plus "
"compréhensible::"

#: ../Doc/howto/functional.rst:1067
msgid ""
"A related function is :func:`itertools.accumulate(iterable, func=operator."
"add) <itertools.accumulate>`.  It performs the same calculation, but instead "
"of returning only the final result, :func:`accumulate` returns an iterator "
"that also yields each partial result::"
msgstr ""
"Une fonction associée est :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  Elle effectue la même "
"opération, mais au lieu de renvoyer seulement le résultat final, :func:"
"`accumulate` renvoie un itérateur composé des résultats intermédiaires::"

#: ../Doc/howto/functional.rst:1080
msgid "The operator module"
msgstr "Le module opérateur"

#: ../Doc/howto/functional.rst:1082
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often "
"useful in functional-style code because they save you from writing trivial "
"functions that perform a single operation."
msgstr ""
"Le module :mod:`operator` a été mentionné plus tôt. Il contient un ensemble "
"de fonctions correspondant aux opérateurs Python. Ces fonctions sont souvent "
"utiles dans du code écrit dans un style fonctionnel car elles vous évitent "
"d'écrire des fonctions triviales qui n'effectue qu'une seule opération."

#: ../Doc/howto/functional.rst:1087
msgid "Some of the functions in this module are:"
msgstr "Quelques fonctions de ce module sont:"

#: ../Doc/howto/functional.rst:1089
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"Opérations mathématiques: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

#: ../Doc/howto/functional.rst:1090
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "Opérations logiques: ``not_()``, ``truth()``."

#: ../Doc/howto/functional.rst:1091
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "Opérations bitwise: ``and_()``, ``or_()``, ``invert()``."

#: ../Doc/howto/functional.rst:1092
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and ``ge()``."
msgstr ""
"Comparaisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, et ``ge()``."

#: ../Doc/howto/functional.rst:1093
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "Nature d'un objet: ``is_()``, ``is_not()``."

#: ../Doc/howto/functional.rst:1095
msgid "Consult the operator module's documentation for a complete list."
msgstr ""
"Consultez la documentation du module opérateur pour une liste complète."

#: ../Doc/howto/functional.rst:1099
msgid "Small functions and the lambda expression"
msgstr "Fonctions courtes et les expressions lambda"

#: ../Doc/howto/functional.rst:1101
msgid ""
"When writing functional-style programs, you'll often need little functions "
"that act as predicates or that combine elements in some way."
msgstr ""
"On ressent souvent le besoin de petites fonctions qui agissent tel des "
"prédicats ou qui combinent des éléments d'une certaine façon lors de "
"l'écriture de programmes dans un style fonctionnel."

#: ../Doc/howto/functional.rst:1104
msgid ""
"If there's a Python built-in or a module function that's suitable, you don't "
"need to define a new function at all::"
msgstr ""
"Si une fonction native ou issue d'un module convient pour l'usage, pas "
"besoin de réécrire de nouvelle fonction::"

#: ../Doc/howto/functional.rst:1110
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to "
"write small functions is to use the :keyword:`lambda` expression.  "
"``lambda`` takes a number of parameters and an expression combining these "
"parameters, and creates an anonymous function that returns the value of the "
"expression::"
msgstr ""
"Si la fonction désirée n'existe pas, il va falloir l'écrire. On peut écrire "
"de courtes fonctions en utilisant le mot-clé :keyword:`lambda` expression.  "
"``lambda``  prend  des paramètres et une expression combinant ces "
"paramètres, et crée une fonction anonyme qui renvoie le résultat de cette "
"expression::"

#: ../Doc/howto/functional.rst:1119
msgid ""
"An alternative is to just use the ``def`` statement and define a function in "
"the usual way::"
msgstr "On peut aussi écrire une fonction classique avec le mot-clé ``def``::"

#: ../Doc/howto/functional.rst:1128
msgid ""
"Which alternative is preferable?  That's a style question; my usual course "
"is to avoid using ``lambda``."
msgstr ""
"Quelle alternative est préférable? C'est une question de style; ``lambda`` "
"est la syntaxe préférée pour le style fonctionnel."

#: ../Doc/howto/functional.rst:1131
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much in a "
"``lambda`` statement, you'll end up with an overly complicated expression "
"that's hard to read.  Quick, what's the following code doing? ::"
msgstr ""
"J'évite d'utiliser ``lambda`` par habitude. ``lambda`` est en effet assez "
"limité dans les fonctions qu'elle peut définir. Le résultat doit être "
"calculable à l'aide d'une seule expression, ce qui signifie qu'on ne peut "
"avoir de conditions type ``if... elif... else`` ou de `` try... except``. Si "
"on crée une ``lambda`` faisant beaucoup d'opérations, on se retrouve avec "
"une expression complexe, difficile à lire. Tenez, dites-moi rapidement ce "
"que fait ce code ::"

#: ../Doc/howto/functional.rst:1141
msgid ""
"You can figure it out, but it takes time to disentangle the expression to "
"figure out what's going on.  Using a short nested ``def`` statements makes "
"things a little bit better::"
msgstr ""
"On peut comprendre le but de ce code, mais cela prend du temps de démêler "
"l'expression pour savoir ce qu'il s'y passe. Utiliser de courtes fonctions "
"(définies avec ``def``) imbriquées peut aider à simplifier la chose::"

#: ../Doc/howto/functional.rst:1151
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "Mais il aurait été plus simple d'utiliser juste une boucle ``for``::"

#: ../Doc/howto/functional.rst:1157
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "Ou la fonction native :func:`sum`  et une expression génératrice::"

#: ../Doc/howto/functional.rst:1161
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for`` "
"loops."
msgstr ""
"Beaucoup d'utilisations de :func:`functools.reduce` sont plus simples "
"écrites à l'aide de boucles ``for``."

#: ../Doc/howto/functional.rst:1163
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring uses "
"of ``lambda``:"
msgstr ""
"Fredrik Lundh suggéra cet ensemble de règles pour redéfinir les utilisations "
"de ``lambda``:"

#: ../Doc/howto/functional.rst:1166
msgid "Write a lambda function."
msgstr "Ecrivez une fonction lambda."

#: ../Doc/howto/functional.rst:1167
msgid "Write a comment explaining what the heck that lambda does."
msgstr "Ecrivez un commentaire à propos de ce que fait cette fichue lambda."

#: ../Doc/howto/functional.rst:1168
msgid ""
"Study the comment for a while, and think of a name that captures the essence "
"of the comment."
msgstr ""
"Etudiez le commentaire pendant un moment, et réfléchissez à un nom qui "
"capture l'essence du commentaire."

#: ../Doc/howto/functional.rst:1170
msgid "Convert the lambda to a def statement, using that name."
msgstr "Convertissez la lambda en une fonction, en utilisant ce nom."

#: ../Doc/howto/functional.rst:1171
msgid "Remove the comment."
msgstr "Enlevez le commentaire."

#: ../Doc/howto/functional.rst:1173
msgid ""
"I really like these rules, but you're free to disagree about whether this "
"lambda-free style is better."
msgstr ""
"J'aime beaucoup ces règles, mais libre à vous de décider si ce style dénué "
"de lambda vous convient ou non."

#: ../Doc/howto/functional.rst:1178
msgid "Revision History and Acknowledgements"
msgstr "Historique des Révisions et Remerciements"

#: ../Doc/howto/functional.rst:1180
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this article: "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike "
"Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."
msgstr ""
"L'auteur aimerait remercier les personnes suivantes pour avoir proposé des "
"suggestions, des corrections, de l'aide sur les différentes ébauches de cet "
"article: Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim "
"Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake "
"Winton, Louis Portay."

#: ../Doc/howto/functional.rst:1185
msgid "Version 0.1: posted June 30 2006."
msgstr "Version 0.1: postée le 30 Juin 2006."

#: ../Doc/howto/functional.rst:1187
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "Version 0.11: postée le 1er Juillet 2006.  Corrections de Typo."

#: ../Doc/howto/functional.rst:1189
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections into "
"one. Typo fixes."
msgstr ""
"Version 0.2: postée le 10 Juillet 2006. Fusion des sections genexp and "
"listcomp en une seule. Corrections de typo."

#: ../Doc/howto/functional.rst:1192
msgid ""
"Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"Version 0.21: Ajout de nouvelles références suggérées sur la liste de "
"diffusion des tuteurs."

#: ../Doc/howto/functional.rst:1194
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by Collin "
"Winter; adds short section on the operator module; a few other edits."
msgstr ""
"Version 0.30: Ajout d'une section sur le module ``functional`` écrit par "
"Collin Winter; ajout d'une courte section sur le module des opérateurs; "
"quelques autres modifications."

#: ../Doc/howto/functional.rst:1199
msgid "References"
msgstr "Références"

#: ../Doc/howto/functional.rst:1202
msgid "General"
msgstr "Général"

#: ../Doc/howto/functional.rst:1204
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson and "
"Gerald Jay Sussman with Julie Sussman.  Full text at https://mitpress.mit."
"edu/sicp/.  In this classic textbook of computer science, chapters 2 and 3 "
"discuss the use of sequences and streams to organize the data flow inside a "
"program.  The book uses Scheme for its examples, but many of the design "
"approaches described in these chapters are applicable to functional-style "
"Python code."
msgstr ""
"**Structure and Interpretation of Computer Programs**, par Harold Abelson et "
"Gerald Jay Sussman avec Julie Sussman. Texte complet (en) https://mitpress."
"mit.edu/sicp/.  Dans ce livre classique d'informatique, les chapitres 2 et 3 "
"traitent de l'utilisation de séquences et de flux pour organiser le parcours "
"de la donnée au sein d'un programme. Ce livre utilise Scheme pour ses "
"exemples, mais beaucoup de ses approches de conception décrites dans ces "
"chapitres sont reproductibles avec du Python écrit dans un style fonctionnel."

#: ../Doc/howto/functional.rst:1212
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy historical "
"introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: Une introduction générale à la "
"programmation fonctionnelle qui utilise des exemples écrits en Java et qui "
"comporte une introduction historique détaillée."

#: ../Doc/howto/functional.rst:1215
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: Entrée Wikipedia "
"généraliste décrivant la programmation fonctionnelle."

#: ../Doc/howto/functional.rst:1218
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr ""
"https://en.wikipedia.org/wiki/Coroutine: Entrée à propos des coroutines."

#: ../Doc/howto/functional.rst:1220
msgid ""
"https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr ""
"https://en.wikipedia.org/wiki/Currying: Entrée à propos du concept de "
"currying."

#: ../Doc/howto/functional.rst:1223
msgid "Python-specific"
msgstr "Spécifique à Python"

#: ../Doc/howto/functional.rst:1225
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming for "
"text processing, in the section titled \"Utilizing Higher-Order Functions in "
"Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: Le premier chapitre du livre de David Mertz :title-"
"reference:`Text Processing in Python` traite de la programmation "
"fonctionnelle dans le cadre du traitement de texte, dans la section "
"intitulée \"Utilizing Higher-Order Functions in Text Processing\"."

#: ../Doc/howto/functional.rst:1230
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming for "
"IBM's DeveloperWorks site; see `part 1 <https://www.ibm.com/developerworks/"
"linux/library/l-prog/index.html>`__, `part 2 <https://www.ibm.com/"
"developerworks/linux/library/l-prog2/index.html>`__, and `part 3 <https://"
"www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"
msgstr ""
"Mertz a aussi écrit une série en 3 parties sur la programmation "
"fonctionnelle pour le site IBM's DeveloperWorks;voir `part 1 <https://www."
"ibm.com/developerworks/linux/library/l-prog/index.html>`__, `part 2 <https://"
"www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__, et `part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"

#: ../Doc/howto/functional.rst:1238
msgid "Python documentation"
msgstr "Documentation Python"

#: ../Doc/howto/functional.rst:1240
msgid "Documentation for the :mod:`itertools` module."
msgstr "Documentation pour le module :mod:`itertools`."

#: ../Doc/howto/functional.rst:1242
msgid "Documentation for the :mod:`functools` module."
msgstr "Documentation pour le module :mod:`functools`."

#: ../Doc/howto/functional.rst:1244
msgid "Documentation for the :mod:`operator` module."
msgstr "Documentation pour le module :mod:`operator`."

#: ../Doc/howto/functional.rst:1246
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"Generator Expressions\""

#: ../Doc/howto/functional.rst:1248
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"Coroutines via Enhanced Generators\" décrit les nouvelles "
"fonctionnalités associées aux générateurs de Python 2.5."
